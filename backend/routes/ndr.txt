complete updated file  Request URL
http://127.0.0.1:8000/api/staff/inwards/118/send-report
Request Method
POST
Status Code
404 Not Found
Remote Address
127.0.0.1:8000
Referrer Policy
strict-origin-when-cross-origin
access-control-allow-credentials
true
access-control-allow-origin
http://localhost:5173
content-length
22
content-type
application/json
date
Sun, 02 Nov 2025 13:38:57 GMT
server
uvicorn
vary
Origin
accept
application/json, text/plain, */*
accept-encoding
gzip, deflate, br, zstd
accept-language
en-US,en;q=0.9
authorization
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo2LCJzdWIiOiI2IiwiZW1haWwiOiJwcmFqd2FsQGdtYWlsLmNvbSIsInJvbGUiOiJlbmdpbmVlciIsImV4cCI6MTc2MjA5MDAxNCwiaWF0IjoxNzYyMDg5MTE0fQ.bxNney5qhfqQ2nqPNXPwIoRrr4mzddx3iuHa5gmVuQo
connection
keep-alive
content-length
52
content-type
application/json
host
127.0.0.1:8000
origin
http://localhost:5173
referer
http://localhost:5173/
sec-ch-ua
"Google Chrome";v="141", "Not?A_Brand";v="8", "Chromium";v="141"
sec-ch-ua-mobile
?0
sec-ch-ua-platform
"Windows"
sec-fetch-dest
empty
sec-fetch-mode
cors
sec-fetch-site
cross-site
user-agent
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36
 also fix this error and srf id updating   import uuid
import os
import aiofiles
import secrets
import string
from typing import List, Dict, Optional
from sqlalchemy.orm import Session
from sqlalchemy import select, and_, desc
from fastapi import HTTPException, status, UploadFile, BackgroundTasks
from datetime import datetime, timezone, timedelta

# Model and Schema imports
from backend.models.inward import Inward
from backend.models.inward_equipments import InwardEquipment
from backend.models.users import User
from backend.models.customers import Customer
from backend.models.invitations import Invitation
from backend.schemas.inward_schemas import InwardCreate, InwardUpdate
from backend.services.delayed_email_services import DelayedEmailService

# Core Service Imports
from backend.core.security import create_invitation_token, hash_password
from backend.core.email import (
    send_new_user_invitation_email,
    send_existing_user_notification_email
)

UPLOAD_DIRECTORY = "uploads/inward_photos"
os.makedirs(UPLOAD_DIRECTORY, exist_ok=True)

class InwardService:
    def __init__(self, db: Session):
        self.db = db

    def _get_receiver_id(self, receiver_name: str) -> int:
        user = self.db.execute(select(User).where(User.username == receiver_name)).scalars().first()
        if not user:
            raise HTTPException(status_code=404, detail=f"Receiver user '{receiver_name}' not found.")
        return user.user_id

    # --- [ALL FIXES APPLIED] ENHANCED AND REFACTORED DRAFT METHODS ---
    
    # FIX: Changed to async def
    async def save_draft(self, draft_data: Dict, user_id: int, inward_id: Optional[int] = None) -> Dict:
        """Save or update a draft inward form with enhanced error handling and validation."""
        try:
            if not draft_data or not isinstance(draft_data, dict):
                raise HTTPException(status_code=400, detail="Invalid draft data")

            if inward_id:
                existing_inward = self.db.get(Inward, inward_id)
                if not existing_inward or existing_inward.created_by != user_id:
                    raise HTTPException(status_code=404, detail="Draft not found or access denied")
                
                if not existing_inward.is_draft:
                    raise HTTPException(status_code=400, detail="Cannot update non-draft inward")
                
                existing_inward.draft_data = draft_data
                existing_inward.draft_updated_at = datetime.now(timezone.utc)
                self.db.commit()
                self.db.refresh(existing_inward)
                
                return {
                    "success": True,
                    "message": "Draft updated successfully",
                    "draft_id": existing_inward.inward_id,
                    "updated_at": existing_inward.draft_updated_at.isoformat()
                }
            else:
                existing_draft = self.db.execute(
                    select(Inward).where(
                        and_(Inward.created_by == user_id, Inward.is_draft == True)
                    ).order_by(desc(Inward.draft_updated_at))
                ).scalars().first()
                
                if existing_draft:
                    existing_draft.draft_data = draft_data
                    existing_draft.draft_updated_at = datetime.now(timezone.utc)
                    self.db.commit()
                    self.db.refresh(existing_draft)
                    
                    return {
                        "success": True,
                        "message": "Draft updated successfully",
                        "draft_id": existing_draft.inward_id,
                        "updated_at": existing_draft.draft_updated_at.isoformat()
                    }
                else:
                    # FIX: Use a numeric placeholder (0) for the INTEGER srf_no column
                    draft_inward = Inward(
                        srf_no=0,
                        date=datetime.now().date(),
                        customer_details=draft_data.get('customer_details', 'Draft') or 'Draft',
                        created_by=user_id,
                        status='draft',
                        is_draft=True,
                        draft_data=draft_data,
                        draft_updated_at=datetime.now(timezone.utc)
                    )
                    
                    self.db.add(draft_inward)
                    self.db.commit()
                    self.db.refresh(draft_inward)
                    
                    return {
                        "success": True,
                        "message": "Draft saved successfully",
                        "draft_id": draft_inward.inward_id,
                        "updated_at": draft_inward.draft_updated_at.isoformat()
                    }
                    
        except HTTPException:
            raise
        except Exception as e:
            self.db.rollback()
            raise HTTPException(status_code=500, detail=f"Failed to save draft: {str(e)}")

    # FIX: Changed to async def
    async def get_user_drafts(self, user_id: int) -> List[Dict]:
        """Get all drafts for a user with enhanced preview information."""
        try:
            drafts = self.db.execute(
                select(Inward).where(
                    and_(Inward.created_by == user_id, Inward.is_draft == True)
                ).order_by(desc(Inward.draft_updated_at))
            ).scalars().all()
            
            result = []
            for draft in drafts:
                preview_title = 'Untitled Draft'
                equipment_count = 0
                
                if draft.draft_data and isinstance(draft.draft_data, dict):
                    customer_details = draft.draft_data.get('customer_details', '').strip()
                    if customer_details:
                        preview_title = customer_details[:50] + ('...' if len(customer_details) > 50 else '')
                    
                    equipment_list = draft.draft_data.get('equipment_list', [])
                    if isinstance(equipment_list, list):
                        equipment_count = len(equipment_list)
                
                result.append({
                    "draft_id": draft.inward_id,
                    "draft_data": draft.draft_data,
                    "created_at": draft.created_at.isoformat(),
                    "updated_at": draft.draft_updated_at.isoformat() if draft.draft_updated_at else draft.created_at.isoformat(),
                    "preview": { "customer_details": preview_title, "equipment_count": equipment_count }
                })
            
            return result
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to retrieve drafts: {str(e)}")

    # FIX: Changed to async def
    async def get_draft(self, draft_id: int, user_id: int) -> Optional[Dict]:
        """Get a specific draft with validation."""
        try:
            draft = self.db.execute(
                select(Inward).where(
                    and_(Inward.inward_id == draft_id, Inward.created_by == user_id, Inward.is_draft == True)
                )
            ).scalars().first()
            
            if not draft: return None
                
            return {
                "draft_id": draft.inward_id,
                "draft_data": draft.draft_data,
                "created_at": draft.created_at.isoformat(),
                "updated_at": draft.draft_updated_at.isoformat() if draft.draft_updated_at else None
            }
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to retrieve draft: {str(e)}")

    # FIX: Changed to async def
    async def delete_draft(self, draft_id: int, user_id: int) -> bool:
        """Delete a draft with proper validation."""
        try:
            draft = self.db.execute(
                select(Inward).where(
                    and_(Inward.inward_id == draft_id, Inward.created_by == user_id, Inward.is_draft == True)
                )
            ).scalars().first()
            
            if not draft: return False
                
            self.db.delete(draft)
            self.db.commit()
            return True
        except Exception as e:
            self.db.rollback()
            raise HTTPException(status_code=500, detail=f"Failed to delete draft: {str(e)}")

    # FIX: Changed to async def
    async def cleanup_old_drafts(self, user_id: int, days_old: int = 30) -> int:
        """Clean up old drafts (utility method)."""
        try:
            cutoff_date = datetime.now(timezone.utc) - timedelta(days=days_old)
            old_drafts = self.db.execute(
                select(Inward).where(
                    and_(Inward.created_by == user_id, Inward.is_draft == True, Inward.draft_updated_at < cutoff_date)
                )
            ).scalars().all()
            
            count = len(old_drafts)
            if count > 0:
                for draft in old_drafts:
                    self.db.delete(draft)
                self.db.commit()
            
            return count
        except Exception as e:
            self.db.rollback()
            raise HTTPException(status_code=500, detail=f"Failed to cleanup drafts: {str(e)}")


    # --- EXISTING METHODS (unchanged) ---

    async def create_inward_with_files(self, inward_data: InwardCreate, files_by_index: Dict[int, List[UploadFile]], creator_id: int) -> Inward:
        try:
            receiver_id = self._get_receiver_id(inward_data.receiver)

            db_inward = Inward(
                srf_no=inward_data.srf_no,
                date=inward_data.date,
                customer_dc_date=inward_data.customer_dc_date,
                customer_details=inward_data.customer_details,
                received_by=receiver_id,
                created_by=creator_id,
                status='created',
                is_draft=False
            )
            self.db.add(db_inward)
            self.db.flush()

            await self._process_equipment_list(db_inward.inward_id, inward_data.equipment_list, files_by_index)
            
            self.db.commit()
            self.db.refresh(db_inward)
            
            return db_inward
        except HTTPException:
            self.db.rollback()
            raise
        except Exception as e:
            self.db.rollback()
            raise HTTPException(status_code=500, detail=f"An internal server error occurred: {e}")

    async def update_inward_with_files(self, inward_id: int, inward_data: InwardUpdate, files_by_index: Dict[int, List[UploadFile]], updater_id: int) -> Inward:
        try:
            db_inward = self.db.get(Inward, inward_id)
            if not db_inward:
                raise HTTPException(status_code=404, detail="Inward record not found.")

            receiver_id = self._get_receiver_id(inward_data.receiver)

            db_inward.srf_no = inward_data.srf_no
            db_inward.date = inward_data.date
            db_inward.customer_dc_date = inward_data.customer_dc_date
            db_inward.customer_details = inward_data.customer_details
            db_inward.received_by = receiver_id
            db_inward.updated_by = updater_id
            db_inward.updated_at = datetime.now(timezone.utc)
            db_inward.is_draft = False

            self.db.query(InwardEquipment).filter(InwardEquipment.inward_id == inward_id).delete(synchronize_session=False)
            self.db.flush()

            await self._process_equipment_list(inward_id, inward_data.equipment_list, files_by_index)
            
            self.db.commit()
            self.db.refresh(db_inward)
            
            return db_inward
        except HTTPException:
            self.db.rollback()
            raise
        except Exception as e:
            self.db.rollback()
            raise HTTPException(status_code=500, detail=f"An internal server error occurred: {e}")

    async def _process_equipment_list(self, inward_id: int, equipment_list: List, files_by_index: Dict[int, List[UploadFile]]):
        equipment_models = []
        for index, eqp_model in enumerate(equipment_list):
            photo_paths = []
            if index in files_by_index:
                for file in files_by_index[index]:
                    if file and file.filename:
                        file_extension = os.path.splitext(file.filename)[1]
                        unique_filename = f"{uuid.uuid4()}{file_extension}"
                        file_path = os.path.join(UPLOAD_DIRECTORY, unique_filename)
                        
                        async with aiofiles.open(file_path, 'wb') as out_file:
                            content = await file.read()
                            await out_file.write(content)
                        photo_paths.append(file_path)

            db_equipment = InwardEquipment(
                inward_id=inward_id,
                nepl_id=eqp_model.nepl_id,
                material_description=eqp_model.material_desc,
                make=eqp_model.make,
                model=eqp_model.model,
                range=eqp_model.range,
                serial_no=eqp_model.serial_no,
                quantity=eqp_model.qty,
                visual_inspection_notes=eqp_model.inspe_notes,
                calibration_by=eqp_model.calibration_by,
                supplier=eqp_model.supplier,
                out_dc=eqp_model.out_dc,
                in_dc=eqp_model.in_dc,
                nextage_contract_reference=eqp_model.nextage_ref,
                qr_code=eqp_model.qr_code,
                barcode=eqp_model.barcode,
                photos=photo_paths,
                remarks=eqp_model.remarks or 'No remarks'
            )
            equipment_models.append(db_equipment)
        
        self.db.add_all(equipment_models)

    def get_all_inwards(self) -> List[Inward]:
        return self.db.execute(
            select(Inward).where(Inward.is_draft.is_(False))
            .order_by(Inward.created_at.desc())
        ).scalars().all()

    def get_inward_by_id(self, inward_id: int) -> Inward:
        db_inward = self.db.get(Inward, inward_id)
        if not db_inward:
            raise HTTPException(status_code=404, detail="Inward record not found.")
        return db_inward

    def generate_temp_password(self, length: int = 10) -> str:
        characters = string.ascii_letters + string.digits
        return ''.join(secrets.choice(characters) for _ in range(length))

    async def process_customer_notification(
        self,
        inward_id: int,
        creator_id: int,
        background_tasks: BackgroundTasks,
        customer_email: Optional[str] = None,
        send_later: bool = False
    ):
        db_inward = self.get_inward_by_id(inward_id)
        if not db_inward.customer_details:
            raise HTTPException(status_code=400, detail="Inward is missing customer details.")

        creator_user = self.db.get(User, creator_id)
        created_by_name = creator_user.username if creator_user else f"user_{creator_id}"

        if send_later:
            delayed_service = DelayedEmailService(self.db)
            delayed_service.schedule_delayed_email(
                inward_id=inward_id,
                recipient_email=customer_email,
                creator_id=creator_id,
                delay_hours=24
            )
            return {"message": f"Report for SRF {db_inward.srf_no} scheduled. Manage it from the Engineer Portal."}

        if not customer_email:
            raise HTTPException(status_code=422, detail="Customer email is required for immediate sending.")

        existing_user = self.db.scalars(select(User).where(User.email == customer_email)).first()

        if existing_user:
            if existing_user.role.lower() != 'customer':
                raise HTTPException(status_code=400, detail="An internal staff account already exists with this email.")
            
            if not db_inward.customer_id and existing_user.customer_id:
                db_inward.customer_id = existing_user.customer_id
                self.db.commit()

            success = await send_existing_user_notification_email(
                background_tasks=background_tasks,
                recipient_email=existing_user.email,
                inward_id=db_inward.inward_id,
                srf_no=db_inward.srf_no,
                db=self.db,
                created_by=created_by_name
            )
            
            if success:
                return {"message": f"Notification sent to existing customer {customer_email}."}
            else:
                raise HTTPException(status_code=500, detail="Failed to queue notification email.")
        else:
            customer = self.db.scalars(select(Customer).where(Customer.customer_details == db_inward.customer_details)).first()
            if not customer:
                customer = Customer(customer_details=db_inward.customer_details, email=customer_email)
                self.db.add(customer)
                self.db.flush()

            db_inward.customer_id = customer.customer_id
            
            temp_password = self.generate_temp_password()
            
            new_user = User(
                email=customer_email,
                username=customer_email,
                password_hash=hash_password(temp_password),
                role='customer',
                is_active=False,
                customer_id=customer.customer_id
            )
            self.db.add(new_user)
            
            invitation_token = create_invitation_token(subject=customer_email)
            new_invitation = Invitation(
                email=customer_email,
                token=invitation_token,
                customer_id=customer.customer_id,
                created_by=creator_id,
            )
            self.db.add(new_invitation)
            self.db.commit()
            
            success = await send_new_user_invitation_email(
                background_tasks=background_tasks,
                recipient_email=customer_email,
                token=invitation_token,
                srf_no=db_inward.srf_no,
                temp_password=temp_password,
                db=self.db,
                inward_id=db_inward.inward_id,
                created_by=created_by_name
            )
            
            if success:
                return {"message": f"Account created and invitation with temporary password sent to {customer_email}."}
            else:
                raise HTTPException(status_code=500, detail="Failed to queue invitation email.")

    async def send_scheduled_report_now(self, task_id: int, customer_email: str, background_tasks: BackgroundTasks) -> bool:
        delayed_service = DelayedEmailService(self.db)
        task = delayed_service.get_task_by_id(task_id)

        if not task:
            raise HTTPException(status_code=404, detail="Scheduled task not found.")
        if task.is_sent or task.is_cancelled:
            raise HTTPException(status_code=400, detail="This task has already been processed.")

        task.recipient_email = customer_email
        self.db.commit()

        await self.process_customer_notification(
            inward_id=task.inward_id,
            creator_id=task.created_by,
            customer_email=customer_email,
            background_tasks=background_tasks,
            send_later=False
        )

        delayed_service.mark_task_as_sent(task_id)
        return True